// Generated by CoffeeScript 1.7.1

/*
wbt.rotator.js v2.0.0

Dependencies: jQuery 1.7+, Snap SVG 0.2+

Basic usage:
$(".any-selector").wbtRotator({
  src: "path/template/{{30}}.jpg",
  masks: [{
    title: "First Mask",
    src: "path/to/mask/{{30}}.svg"
  }, {
    title: "Second Mask",
    src: "path/to/mask/{{30}}.svg"
  }]
});

Copyright 2014, VisualScience, http://visualscience.ru/
Created by WBâ€”Tech, http://wbtech.pro/
 */

(function() {
  (function($) {
    var WBTRotator;
    WBTRotator = function($el, params) {
      this.cfg = $.extend({}, WBTRotator.prototype.defaults, params);
      this.cfg.frameSrc = this.createSrcArray(this.cfg.src);
      this.cfg.maskSrc = this.cfg.masks;
      this.$el = $el.addClass("wbt-rotator");
      this.$frameCurrent = $();
      this.$frames = $();
      this.frames = {
        previous: 0,
        current: this.cfg.frameFirst,
        total: this.cfg.frameSrc.length,
        loaded: 0,
        size: {
          width: 0,
          height: 0
        }
      };
      this.$masks = {};
      this.masks = {
        current: "",
        titles: this.cfg.maskSrc.length,
        total: this.cfg.maskSrc.length * this.frames.total,
        loaded: 0
      };
      this.pointerPressed = false;
      this.pointerPosition = {
        x: 0,
        y: 0
      };
      if (!this.$el.length) {
        return $.wbtError("Specify non empty rotator placeholder.");
      }
      if (!this.cfg.frameSrc) {
        return $.wbtError("Specify 'src' in $().wbtRotator() call.");
      }
      this.$loader = $("<span></span>").attr({
        "class": "wbt-rotator-loader"
      }).prependTo(this.$el);
      if (!this.cfg.frameCover) {
        this.cfg.frameCover = this.cfg.frameSrc[0];
      }
      this.loadCover();
      if (this.cfg.rotateManual) {
        if (this.cfg.cursor === "arrows") {
          if (this.cfg.invertAxes) {
            this.$el.addClass("wbt-rotator__vertical");
          } else {
            this.$el.addClass("wbt-rotator__horizontal");
          }
        } else {
          if (this.cfg.cursor === "grab") {
            this.$el.addClass("wbt-rotator__grab");
          }
        }
      }
      this.$el.on("click.wbt-rotator", $.proxy(this.loadImages, this));
      if (this.cfg.autoLoad) {
        this.loadImages();
      }
      this.maskSVG = Snap();
      this.$maskSVG = $(this.maskSVG.node);
      this.$maskSVG.appendTo(this.$el).attr({
        "class": "wbt-rotator-mask"
      });
      this.$maskTitle = $("<span></span>").attr({
        "class": "wbt-rotator-title"
      }).prependTo(this.$el);
      if (typeof this.cfg.maskSrc === "object") {
        this.$el.on("click.wbt-rotator", $.proxy(this.loadSVG, this));
        if (this.cfg.autoLoad) {
          this.loadSVG();
        }
      } else {

      }
    };
    WBTRotator.prototype.defaults = {
      frameCover: "",
      frameSrc: "",
      frameFirst: 0,
      leadingZero: true,
      autoLoad: true,
      rotateAuto: false,
      rotateAutoSpeed: 100,
      rotateManual: true,
      invertAxes: false,
      invertMouse: false,
      invertAutoRotate: false,
      enableMouseWheel: true,
      cursor: "grab"
    };
    WBTRotator.prototype.registerEvents = function() {
      this.$el[0].addEventListener(($.wbtIsTouch() ? "touchstart" : "mousedown"), $.proxy(this.onPointerDown, this));
      document.addEventListener(($.wbtIsTouch() ? "touchend" : "mouseup"), $.proxy(this.onPointerUp, this));
      document.addEventListener(($.wbtIsTouch() ? "touchmove" : "mousemove"), $.proxy(this.onPointerMove, this));
      if (this.cfg.enableMouseWheel) {
        this.$el.on("mousewheel DOMMouseScroll", $.proxy(this.onScroll, this));
      }
      if (this.cfg.rotateAuto) {
        this.$el.on("mouseenter", $.proxy(this.onPointerEnter, this));
        this.$el.on("mouseleave", $.proxy(this.onPointerLeave, this));
      }
    };
    WBTRotator.prototype.createSrcArray = function(template) {
      var i, itemCount, itemCountLength, itemIndex, itemIndexLength, itemSrcArray;
      itemCount = parseInt(template.replace(/.*{{|}}.*/g, ""));
      itemCountLength = ("" + itemCount).length;
      itemIndex = 0;
      itemIndexLength = 0;
      itemSrcArray = [];
      i = 0;
      while (i < itemCount) {
        itemIndex = i;
        if (this.cfg.leadingZero) {
          while (itemIndexLength = ("" + itemIndex).length < itemCountLength) {
            itemIndex = "0" + itemIndex;
          }
        }
        itemSrcArray.push(template.replace(/{{.*}}/, itemIndex));
        i++;
      }
      return itemSrcArray;
    };
    WBTRotator.prototype.updateLoader = function() {
      this.$loader.css("background-position", "left -" + (Math.round((this.frames.loaded + this.masks.loaded) * 60 / (this.frames.total + this.masks.total)) * 40) + "px");
    };
    WBTRotator.prototype.loadCover = function() {
      this.$cover = $("<img />").attr({
        "class": "wbt-rotator-cover",
        src: this.cfg.frameCover,
        alt: ""
      }).appendTo(this.$el).on("load", (function(_this) {
        return function() {
          _this.frames.size = {
            width: _this.$cover.width(),
            height: _this.$cover.height()
          };
          _this.$el.width(_this.frames.size.width).height(_this.frames.size.height);
        };
      })(this));
    };
    WBTRotator.prototype.loadSVG = function() {
      var getCallback, i, index, mask, maskSrc, _i, _j, _len, _ref, _ref1, _results;
      _ref = this.cfg.maskSrc;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        mask = _ref[index];
        this.cfg.maskSrc[index].srcArray = this.createSrcArray(mask.src);
      }
      _results = [];
      for (i = _j = 0, _ref1 = this.frames.total - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _results.push((function() {
          var _k, _len1, _ref2, _results1;
          _ref2 = this.cfg.maskSrc;
          _results1 = [];
          for (index = _k = 0, _len1 = _ref2.length; _k < _len1; index = ++_k) {
            maskSrc = _ref2[index];
            getCallback = (function(_this) {
              return function(title, index) {
                return function(data) {
                  return _this.loadedSVG(data, title, index);
                };
              };
            })(this);
            _results1.push($.get(maskSrc.srcArray[i], getCallback(this.cfg.maskSrc[index].title, i)));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };
    WBTRotator.prototype.loadedSVG = function(documentSVG, title, index) {
      var imageNew, mask, path, pathClickHandler, pathGroup, self, _i, _j, _len, _len1, _ref, _ref1;
      this.masks.loaded++;
      this.updateLoader();
      if (this.$masks[title] == null) {
        this.$masks[title] = {};
      }
      if (this.$masks[title].paths == null) {
        this.$masks[title].paths = [];
      }
      if (this.$masks[title].images == null) {
        this.$masks[title].images = [];
      }
      imageNew = this.maskSVG.image(this.cfg.frameSrc[index], 0, 0);
      imageNew.attr("display", "none");
      pathGroup = this.maskSVG.g().attr({
        display: "none",
        fill: "transparent",
        cursor: "pointer"
      });
      self = this;
      pathClickHandler = function() {
        var mask, _i, _len, _ref, _results;
        if (!self.masks.current) {
          self.masks.current = this.data("title");
          self.$maskTitle.text(self.masks.current);
          self.$el.addClass("wbt-rotator-mask__active");
        } else {
          self.masks.current = "";
          self.$el.removeClass("wbt-rotator-mask__active");
        }
        _ref = self.cfg.maskSrc;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          mask = _ref[_i];
          if (self.masks.current && mask.title !== self.masks.current) {
            self.$masks[mask.title].paths[self.frames.current].attr({
              "display": "none"
            });
            _results.push(self.$masks[mask.title].images[self.frames.current].attr({
              "display": "none"
            }));
          } else {
            self.$masks[mask.title].paths[self.frames.current].attr({
              "display": ""
            });
            _results.push(self.$masks[mask.title].images[self.frames.current].attr({
              "display": ""
            }));
          }
        }
        return _results;
      };
      $(documentSVG).find("path").each((function(_this) {
        return function(index, el) {
          var pathNew;
          pathNew = _this.maskSVG.path($(el).attr("d"));
          pathNew.transform("s.25,.25,0,0");
          pathNew.click(pathClickHandler);
          pathNew.touchstart(pathClickHandler);
          pathNew.data("index", index);
          pathNew.data("title", title);
          return pathGroup.add(pathNew);
        };
      })(this));
      this.$masks[title].paths[index] = pathGroup;
      imageNew.attr("mask", pathGroup.clone().attr({
        fill: "#fff",
        display: ""
      }));
      this.$masks[title].images[index] = imageNew;
      if (this.masks.loaded === this.masks.total) {
        _ref = this.cfg.maskSrc;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          mask = _ref[_i];
          _ref1 = this.$masks[mask.title].paths;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            path = _ref1[_j];
            path.appendTo(this.maskSVG);
          }
        }
        if (this.frames.loaded === this.frames.total) {
          return this.loadComplete();
        }
      }
    };
    WBTRotator.prototype.loadImages = function() {
      var i, _i, _ref;
      this.$el.off("click.wbt-rotator").addClass("wbt-rotator__loading");
      for (i = _i = 0, _ref = this.frames.total; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        $("<img />").attr({
          "class": "wbt-rotator-image",
          src: this.cfg.frameSrc[i],
          alt: ""
        }).appendTo(this.$el).on("load", (function(_this) {
          return function(e) {
            var $this;
            _this.frames.loaded++;
            _this.updateLoader();
            if (_this.frames.loaded === 1 && !_this.frameCover) {
              $this = $(e.target);
              _this.frames.size = {
                width: $this.width(),
                height: $this.height()
              };
              _this.$el.width(_this.frames.size.width);
              _this.$el.height(_this.frames.size.height);
            }
            if (_this.frames.loaded === _this.frames.total && _this.masks.loaded === _this.masks.total) {
              _this.loadComplete();
            }
          };
        })(this));
      }
    };
    WBTRotator.prototype.loadComplete = function() {
      this.$frames = this.$el.children(".wbt-rotator-image");
      this.changeFrame(this.frames.current);
      this.$el.removeClass("wbt-rotator__loading").addClass("wbt-rotator__loaded");
      this.registerEvents();
      if (this.cfg.rotateAuto) {
        this.startAutoRotate();
      }
    };
    WBTRotator.prototype.onPointerDown = function(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
      this.$el.addClass("wbt-rotator__active");
      this.pointerPressed = true && this.cfg.rotateManual;
      this.pointerPosition.x = e.pageX;
      this.pointerPosition.y = e.pageY;
    };
    WBTRotator.prototype.onPointerUp = function() {
      if (this.pointerPressed) {
        this.$el.removeClass("wbt-rotator__active");
        this.pointerPressed = false;
        this.frames.current = this.$el.children(".wbt-rotator-image").index(this.$frameCurrent);
      }
    };
    WBTRotator.prototype.onPointerMove = function(e) {
      var delta;
      if (this.pointerPressed) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
        delta = void 0;
        if (this.cfg.invertAxes) {
          delta = e.pageY - this.pointerPosition.y;
        } else {
          delta = e.pageX - this.pointerPosition.x;
        }
        delta = Math.floor(delta * this.frames.total / (this.invertAxes ? this.frames.size.height : this.frames.size.width));
        if (this.cfg.invertMouse) {
          delta = this.frames.current - delta;
        } else {
          delta = this.frames.current + delta;
        }
        this.changeFrame(delta);
      }
    };
    WBTRotator.prototype.onPointerEnter = function() {};
    WBTRotator.prototype.onPointerLeave = function() {};
    WBTRotator.prototype.onScroll = function(e, delta) {
      var scrollUp;
      if (this.cfg.rotateManual) {
        e.preventDefault();
        scrollUp = void 0;
        if (undefined !== e.wheelDelta) {
          scrollUp = e.wheelDelta > 0;
        } else if (undefined !== e.detail) {
          scrollUp = e.detail > 0;
        } else {
          scrollUp = e.originalEvent.wheelDelta > 0;
        }
        this.frames.current %= this.frames.total;
        if (scrollUp) {
          ++this.frames.current;
        } else {
          --this.frames.current;
        }
        this.changeFrame(this.frames.current);
      }
    };
    WBTRotator.prototype.changeFrame = function(newIndex) {
      var mask, _i, _len, _ref;
      newIndex %= this.frames.total;
      newIndex += this.frames.total;
      newIndex %= this.frames.total;
      if (newIndex === this.framePrevious) {
        return;
      }
      this.$frameCurrent.removeClass("wbt-rotator-image__active");
      this.$frameCurrent = this.$frames.eq(newIndex);
      this.$frameCurrent.addClass("wbt-rotator-image__active");
      _ref = this.cfg.maskSrc;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mask = _ref[_i];
        this.$masks[mask.title].paths[this.frames.previous].attr({
          "display": "none"
        });
        this.$masks[mask.title].images[this.frames.previous].attr({
          "display": "none"
        });
        if (!this.masks.current || mask.title === this.masks.current) {
          this.$masks[mask.title].paths[newIndex].attr({
            "display": ""
          });
          this.$masks[mask.title].images[newIndex].attr({
            "display": ""
          });
        }
      }
      this.frames.previous = newIndex;
    };
    WBTRotator.prototype.startAutoRotate = function() {
      setInterval(((function(_this) {
        return function() {
          if (_this.cfg.invertAutoRotate) {
            ++_this.frames.current;
          } else {
            --_this.frames.current;
          }
          if (!_this.pointerPressed) {
            _this.changeFrame(_this.frames.current);
          }
        };
      })(this)), this.cfg.rotateAutoSpeed);
    };
    WBTRotator.prototype.stopAutoRotate = function() {};
    $.wbtError = function(error) {
      if (window.console && window.console.error) {
        console.error(error);
      }
    };
    $.wbtIsTouch = function() {
      if (("ontouchstart" in window) || (window.DocumentTouch && document instanceof DocumentTouch)) {
        return true;
      } else {
        return false;
      }
    };
    $.fn.wbtRotator = function(params) {
      return new WBTRotator(this, params);
    };
  })(jQuery);

}).call(this);
